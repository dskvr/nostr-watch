<template>
  <span 
    v-if="!store.tasks.isActive || store.tasks.getActiveSlug === this.taskSlug"
    class="inline-block mt-0.5">
    <span
      class="text-white lg:text-sm mr-2 ml-2 text-xs">

      <span v-if="!store.tasks.isProcessing(this.taskSlug)">Checked {{ sinceLast }} ago</span>
      <span v-if="store.tasks.isProcessing(this.taskSlug)" class="italic lg:pr-9">
        <svg class="animate-spin mr-1 -mt-0.5 h-4 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        {{ this.store.tasks.getProcessed(this.taskSlug).length }}/{{ this.relays.length }} Relays Checked
      </span>
    </span>
    <span class="text-white text-sm mr-2" v-if="!store.tasks.isProcessing(this.taskSlug)">-</span>
    <span class="text-white text-sm mr-2" v-if="store.prefs.refresh && !store.tasks.isProcessing(this.taskSlug)"> 
      Next check in: {{ untilNext  }}
    </span>
    <button 
      v-if="!store.tasks.isProcessing(this.taskSlug)"
      class="mr-8 my-1 py-0 px-3 text-xs rounded border-b-3 border-slate-700 bg-slate-500  font-bold text-white hover:border-slate-500 hover:bg-slate-400" 
      :disabled='store.tasks.isProcessing(this.taskSlug)' 
      @click="refreshNow()">
        Check{{ relay ? ` ${relay}` : "" }} Now
    </button>
  </span>
</template>

<style scoped>

</style>

<script>
import { defineComponent, toRefs } from 'vue'

import { setupStore } from '@/store'
import RelaysLib from '@/shared/relays-lib.js'
// import History from '@/shared/history.js'
import SharedComputed from '@/shared/computed.js'

import { Inspector } from 'nostr-relay-inspector'
// import sizeof from 'object-sizeof'

import { relays } from '../../../../relays.yaml'
import { geo } from '../../../../cache/geo.yaml'

const localMethods = {

  migrateLegacy(){
    let hit = false 
    for(let i=0;i<relays.length;i++) {
      const cache = localStorage.getItem(`nostrwatch_${relays[i]}`)
      if(!cache) 
        continue
      hit = true 
      break;
    }
    if(hit){
      relays.forEach( relay => {
        const oldKey = `nostrwatch_${relay}`
        const oldCache = localStorage.getItem(oldKey)
        if(oldCache instanceof Object)
          this.setCache(oldCache)
        localStorage.removeItem(oldKey)
      })
    }
  },

  queueJob: function(id, fn, unique){
    this.store.tasks.addJob({
      id: id,
      handler: fn,
      unique: unique
    })
  },

  setRefreshInterval: function(){
    clearInterval(this.interval)
    this.interval = setInterval(() => {
      if(!this.store.prefs.refresh )
        return 
      
      this.untilNext = this.timeUntilRefresh()
      this.sinceLast = this.timeSinceRefresh()

      if(this.store.tasks.getProcessed(this.taskSlug).length >= this.relays.length){
        this.store.tasks.updateNow(this.taskSlug)
        this.store.tasks.finishProcessing(this.taskSlug)
      }

      if(!this.store.tasks.isProcessing(this.taskSlug))
        this.invalidate()
        
    }, 1000)
  },
  refreshNow(){
    this.invalidate(true)
  },
  handleVisibility(){
    if(document.visibilityState === 'hidden')
      this.windowActive = false 
    else 
      this.windowActive = true

    if(this.windowActive) 
      this.store.layout.setActiveTab(this.$tabId)
  },

  invalidate: async function(force, single){
    // console.log('expired', !this.store.tasks.getLastUpdate(this.taskSlug), Date.now() - this.store.tasks.getLastUpdate(this.taskSlug) > this.store.prefs.expireAfter)
    if( (!this.isExpired(this.taskSlug) && !force) ) 
      return

    // console.log('windowActive', this.windowActive)
    if(!this.windowActive)
      return

    this.queueJob(this.taskSlug, async () => {
      const relays = this.relays.filter( relay => !this.store.tasks.isProcessed(this.taskSlug, relay) )

      console.log('unprocessed relays', 
        this.relays.filter( relay => !this.store.tasks.getProcessed(this.taskSlug).includes(relay)))

      if(single) {
        await this.check(single)
      } 
      else {
        for(let index = 0; index < relays.length; index++) {
          await this.delay(this.averageLatency)
          const relay = relays[index]
          this.check(relay)
            .then((result) => this.completeRelay(relay, result) )
            // .then( async () => {
            //   // this.history = await History()
            // })
            .catch( () => this.completeRelay(relay) )
        }
      } 
    }, true)

    // console.log('queue', this.store.tasks.getActive)
    
  },

  completeRelay: function(relay, result){
    if(this.store.tasks.isProcessed(this.taskSlug, relay))
      return 

    this.store.tasks.addProcessed(this.taskSlug, relay)
    
    if(result)  {
      this.results[relay] = result
      this.setCache(result)
    }
      
    if(this.store.tasks.getProcessed(this.taskSlug).length >= this.relays.length)
      this.completeAll()
  },

  completeAll: function(){
    //console.log('completed')
    this.store.tasks.completeJob()
    // this.store.tasks.finishProcessing(this.taskSlug)
    this.store.tasks.updateNow(this.taskSlug)
    this.store.relays.setAggregateCache('public', Object.keys(this.results).filter( result => this.results[result].aggregate === 'public' ))
    this.store.relays.setAggregateCache('restricted', Object.keys(this.results).filter( result => this.results[result].aggregate === 'restricted' ))
    this.store.relays.setAggregateCache('offline', Object.keys(this.results).filter( result => this.results[result].aggregate === 'offline' ))
    //console.log('all are complete?', !this.store.tasks.isProcessing)
    this.setAverageLatency()
  },

  check: async function(relay){
    return new Promise( (resolve) => {
      const opts = {
          checkLatency: true,          
          getInfo: true,
          getIdentities: true,
          // debug: true,
          connectTimeout: this.getDynamicTimeout,
          readTimeout: this.getDynamicTimeout,
          writeTimeout: this.getDynamicTimeout,
        }
      
      if(this.store.user.testEvent)
        opts.testEvent = this.store.user.testEvent

      let socket = new Inspector(relay, opts)

      socket
        .on('complete', (instance) => {
          // console.log('completed?', instance.result)
          instance.result.aggregate = this.getAggregate(instance.result)
          instance.relay.close()
          instance.result.log = instance.log
          resolve(instance.result)
        })
        .run()
        // .on('close', () => {
        //   //console.log(`${relay.url} has closed`)
        //   // reject()
        // })
        // .on('error', () => {
        //   // console.log(result)
        //   // reject()
        // })
        
    })
  },
  
  setAverageLatency: function(){
    const latencies = new Array()
    this.relays.forEach( relay => {
      latencies.push(this.results[relay]?.latency?.final)
    })
    this.averageLatency =  this.average(latencies)
  },

  average(arr){
    let sum = 0,
        total = arr.length;
    for (let i = 0;i<total;i++) 
      sum += arr[i];
    return Math.floor(parseFloat(sum/total));
  },
  timeUntilRefresh(){
    return this.timeSince(Date.now()-(this.store.tasks.getLastUpdate(this.taskSlug)+this.store.prefs.duration-Date.now())) 
  },
  timeSinceRefresh(){
    return this.timeSince(this.store.tasks.getLastUpdate(this.taskSlug)) || Date.now()
  },
}

export default defineComponent({
  name: 'RefreshComponent',
  components: {},
  setup(props){
    const {resultsProp: results} = toRefs(props)
    return { 
      store : setupStore(),
      results: results
    }
  },
  data() {
    return {
      relay: "",
      relays: [],
      refresh: {},
      untilNext: null,
      lastUpdate: null,
      sinceLast: null,
      interval: null,
      windowActive: true,
      averageLatency: 200,
      pageOpen: 0,
      taskSlug: 'relays/check'
      // history: null
    }
  },
  created(){
    clearInterval(this.interval)
    // document.addEventListener("visibilitychange", () => {
    //   if(document.visibilityState == 'visible')
    //     this.store.layout.setActiveTab(this.$tabid)
    //   // if 
      
    //   //   document.title = document.hidden ? "I'm away" : "I'm here";
    // });
    document.body.onfocus = () => {
      // alert('tab focused')
      //console.log(`tab #${this.$tabId} is active`)
      
    }
    document.addEventListener('visibilitychange', this.handleVisibility, false)
  },
  unmounted(){
    clearInterval(this.interval)
    // document.removeEventListener("visibilitychange", this.handleVisibility, false);
  },
  beforeMount(){
    this.lastUpdate = this.store.tasks.getLastUpdate(this.taskSlug)
    this.untilNext = this.timeUntilRefresh()
    this.sinceLast = this.timeSinceRefresh()
    
    this.relays = Array.from(new Set(relays))
    this.store.relays.setRelays(relays)
    this.store.relays.setGeo(geo)
    
    //console.log('total relays', this.relays, this.relays.length)

    for(let ri=0;ri-this.relays.length;ri++){
      const relay = this.relays[ri],
            cache = this.getCache(relay)
      this.results[relay] = cache
      // //console.log('result', 'from result', this.results[relay], 'from cache', cache) 
    }
  },
  mounted(){
    this.migrateLegacy()

    // console.log('is processing', this.store.tasks.isProcessing(this.taskSlug))

    if(this.store.tasks.isProcessing(this.taskSlug))
      this.invalidate(true)
    else
      this.invalidate()

    this.setRefreshInterval()
  },
  updated(){},
  computed: Object.assign(SharedComputed, {
    getDynamicTimeout: function(){
      const calculated = this.averageLatency*this.relays.length
      return calculated > 10000 ? calculated : 10000
    },
  }),
  methods: Object.assign(localMethods, RelaysLib),
  props: {
    resultsProp: {
      type: Object,
      default(){
        return {}
      }
    },
  },
})
</script>

<style scoped>
 #refresh { font-size: 12pt; color:#666; margin-bottom:15px }
 #refresh button { cursor: pointer; border-radius: 3px; border: 1px solid #a0a0a0; color:#333 }
 #refresh button:hover {color:#000;}
 #refresh button[disabled] {color:#999 !important; border-color:#e0e0e0}
</style>

